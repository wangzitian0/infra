# Atlantis Repo Configuration
# Layer Structure: 1.bootstrap (L1), 2.platform (L2), envs/{env}/3.data (L3), 4.apps (L4)
#
# TF VERSION: Atlantis uses required_version constraint from terragrunt-generated versions.tf
# This ensures consistency with .terraform-version (SSOT) used by CI and local dev.
#
# DIRECTORY STRUCTURE:
#   2.platform/             → L2 singleton (shared by all environments)
#   envs/staging/3.data/    → L3 staging data layer
#   envs/prod/3.data/       → L3 production data layer
#   4.apps/                 → L4 singleton control plane (manages all environments)

version: 3

# Allow parallel plan execution, apply remains serial
# Prevents plan failure from blocking other PRs
parallel_plan: true
parallel_apply: false

projects:
  # L1: Bootstrap (GitHub Actions only, NOT managed by Atlantis)
  # - name: bootstrap
  #   dir: 1.bootstrap
  #   ... (Disabled - L1 should only be managed by GitHub Actions)

  # L2: Platform (Singleton - shared by all environments)
  - name: platform
    dir: 2.platform
    terraform_version: "1.11.0"  # Must match .terraform-version
    workflow: terragrunt
    autoplan:
      enabled: true

  # L3: Data (Staging Environment)
  - name: data-staging
    dir: envs/staging/3.data
    terraform_version: "1.11.0"  # Must match .terraform-version
    workflow: terragrunt
    autoplan:
      enabled: true

  # L3: Data (Production Environment)
  - name: data-prod
    dir: envs/prod/3.data
    terraform_version: "1.11.0"  # Must match .terraform-version
    workflow: terragrunt
    autoplan:
      enabled: true

  # L4: Apps (Singleton - Control Plane)
  # Multi-environment workload separation is handled at application level:
  # - Kubero: via Pipeline (env) + Phase (stage within env)
  # - SigNoz: monitors all environments from single deployment
  - name: apps
    dir: 4.apps
    terraform_version: "1.11.0"  # Must match .terraform-version
    workflow: terragrunt
    autoplan:
      enabled: true

workflows:
  # Unified Terragrunt Workflow
  # All layers (L2/L3/L4) use this single workflow
  # Backend and provider configuration is auto-generated by Terragrunt
  terragrunt:
    plan:
      steps:
        - run: echo "infra-flash-commit:$(git rev-parse --short ${HEAD_COMMIT:-HEAD}) "

        # Install terragrunt if not present (install to /atlantis-data/bin like terraform)
        - run: |
            if ! command -v terragrunt &> /dev/null; then
              echo "Installing terragrunt..."
              wget -q -O /atlantis-data/bin/terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v0.96.1/terragrunt_linux_amd64
              chmod +x /atlantis-data/bin/terragrunt
              terragrunt --version
            else
              echo "Terragrunt already installed: $(terragrunt --version)"
            fi

        # L2-specific: Remove stale resources (idempotent, safe for all layers)
        - run: |
            terraform state rm kubernetes_namespace.platform 2>/dev/null || true

        # L3-specific: Import existing resources if they exist but not in state
        # This handles state sync after Terragrunt migration or manual resource creation
        - run: |
            if [[ "$REPO_REL_DIR" == envs/*/3.data ]]; then
              # Determine namespace name based on environment path (staging/prod)
              ENV=$(echo "$REPO_REL_DIR" | grep -oP 'envs/\K[^/]+')
              NS="data-${ENV}"
              TG="TG_TF_PATH=/atlantis-data/bin/terraform1.11.0 terragrunt"
              echo "=== L3 Resource Import Check (NS: $NS) ==="

              # Import namespace if exists but not in state
              if kubectl get ns "$NS" 2>/dev/null && ! eval "$TG state show kubernetes_namespace.data" 2>/dev/null; then
                echo "Importing kubernetes_namespace.data..."
                eval "$TG import kubernetes_namespace.data $NS" || true
              fi

              # Import helm releases if they exist but not in state
              declare -A HELM_RELEASES=(
                ["helm_release.postgresql"]="postgresql"
                ["helm_release.redis"]="redis"
                ["helm_release.clickhouse"]="clickhouse"
                ["helm_release.arangodb_operator"]="arangodb-operator"
              )
              for tf_resource in "${!HELM_RELEASES[@]}"; do
                release_name="${HELM_RELEASES[$tf_resource]}"
                if helm status "$release_name" -n "$NS" 2>/dev/null && ! eval "$TG state show $tf_resource" 2>/dev/null; then
                  echo "Importing $tf_resource..."
                  eval "$TG import $tf_resource $NS/$release_name" || true
                fi
              done

              # Import kubernetes_secret.arangodb_jwt if exists but not in state
              if kubectl get secret arangodb-jwt -n "$NS" 2>/dev/null && ! eval "$TG state show kubernetes_secret.arangodb_jwt" 2>/dev/null; then
                echo "Importing kubernetes_secret.arangodb_jwt..."
                eval "$TG import kubernetes_secret.arangodb_jwt $NS/arangodb-jwt" || true
              fi
            fi

        # Clean up old Terragrunt-generated files to prevent duplicate required_providers error
        # Only clean .tf files, NOT .terraform (needed for dependency output resolution)
        - run: |
            echo "Cleaning old generated .tf files..."
            rm -f versions_providers_*.tf versions_providers_common.tf providers_common.tf providers_layer.tf 2>/dev/null || true
            rm -rf .terragrunt-cache 2>/dev/null || true
            echo "✅ Cleanup complete"

        # Terragrunt auto-generates backend.tf and providers.tf before init
        # Use TG_TF_PATH (new) instead of deprecated TERRAGRUNT_TFPATH
        - run: TG_TF_PATH=/atlantis-data/bin/terraform1.11.0 terragrunt plan -input=false -out=$PLANFILE

    apply:
      steps:
        - run: echo "infra-flash-commit:$(git rev-parse --short ${HEAD_COMMIT:-HEAD}) "

        # Install terragrunt if not present (apply might run in different container)
        - run: |
            if ! command -v terragrunt &> /dev/null; then
              echo "Installing terragrunt..."
              wget -q -O /atlantis-data/bin/terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v0.96.1/terragrunt_linux_amd64
              chmod +x /atlantis-data/bin/terragrunt
            fi

        # Terragrunt apply (uses PLANFILE from plan step)
        # Use TG_TF_PATH (new) instead of deprecated TERRAGRUNT_TFPATH
        - run: TG_TF_PATH=/atlantis-data/bin/terraform1.11.0 terragrunt apply -input=false $PLANFILE
