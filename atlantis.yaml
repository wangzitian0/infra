# Atlantis Repo Configuration
# Layer Structure: 1.bootstrap (L1), 2.platform (L2), 3.data (L3), 4.apps (L4)

version: 3

# Allow parallel plan execution, apply remains serial
# Prevents plan failure from blocking other PRs
parallel_plan: true
parallel_apply: false

projects:
  # L1: Bootstrap (GitHub Actions only, NOT managed by Atlantis)
  # - name: bootstrap
  #   dir: 1.bootstrap
  #   ... (Disabled - L1 should only be managed by GitHub Actions)

  # L2: Platform (Singleton)
  - name: platform
    dir: 2.platform
    terraform_version: 1.6.6
    workspace: default
    execution_order_group: 0
    workflow: platform
    autoplan:
      enabled: false

  # L3: Data (per-env)
  - name: data-staging
    dir: 3.data
    terraform_version: 1.6.6
    workspace: staging
    execution_order_group: 10
    workflow: data
    autoplan:
      enabled: false

  - name: data-prod
    dir: 3.data
    terraform_version: 1.6.6
    workspace: prod
    execution_order_group: 20
    workflow: data
    autoplan:
      enabled: false

  # L4: Apps (per-env)
  - name: apps-staging
    dir: 4.apps
    terraform_version: 1.6.6
    workspace: staging
    execution_order_group: 10
    workflow: apps
    autoplan:
      enabled: false

  - name: apps-prod
    dir: 4.apps
    terraform_version: 1.6.6
    workspace: prod
    execution_order_group: 20
    workflow: apps
    autoplan:
      enabled: false

workflows:
  # L2: Platform
  # NOTE: Platform is a singleton (no per-env tfvars). Config is read from L1 state.
  platform:
    plan:
      steps:
        - run: rm -rf .terraform
        - run: |
            cat > backend.tfvars <<EOF
            bucket    = "${R2_BUCKET}"
            key       = "k3s/platform.tfstate"
            endpoints = { s3 = "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" }
            EOF
        - init:
            extra_args: ["-backend-config=backend.tfvars"]
        # Remove stale L2 namespace state entry (namespace is owned by L1).
        # NOTE: Do this in plan only; doing it again in apply would invalidate the saved plan.
        - run: terraform state rm kubernetes_namespace.platform 2>/dev/null || true
        - plan
    apply:
      steps:
        # Reuse .terraform from plan step to avoid state lineage mismatch
        - apply

  # L3: Data
  data:
    plan:
      steps:
        - run: rm -rf .terraform
        - run: |
            cat > backend.tfvars <<EOF
            bucket    = "${R2_BUCKET}"
            key       = "k3s/data-${WORKSPACE}.tfstate"
            endpoints = { s3 = "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" }
            EOF
        # Debug: verify TF_VAR_vault_root_token is in environment
        - run: |
            echo "=== TF_VAR Debug ==="
            echo "TF_VAR_vault_root_token length: ${#TF_VAR_vault_root_token}"
            if [ -n "$TF_VAR_vault_root_token" ]; then
              echo "TF_VAR_vault_root_token is SET"
            else
              echo "TF_VAR_vault_root_token is EMPTY or NOT SET"
            fi
        - init:
            extra_args: ["-backend-config=backend.tfvars"]
        - plan
    apply:
      steps:
        # Reuse .terraform from plan step to avoid state lineage mismatch
        - apply

  # L4: Apps
  apps:
    plan:
      steps:
        - run: rm -rf .terraform
        - run: |
            cat > backend.tfvars <<EOF
            bucket    = "${R2_BUCKET}"
            key       = "k3s/apps-${WORKSPACE}.tfstate"
            endpoints = { s3 = "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" }
            EOF
        - init:
            extra_args: ["-backend-config=backend.tfvars"]
        - plan
    apply:
      steps:
        # Reuse .terraform from plan step to avoid state lineage mismatch
        - apply
