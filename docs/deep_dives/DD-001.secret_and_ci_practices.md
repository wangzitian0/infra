# DD-001: Infrastructure Design Decisions & Deep Dives

This document captures key architectural Q&A and design rationale discussed during the initial infrastructure setup.

**Date**: 2025-12-06
**Topics**: SSOT, Secret Management Strategy

---

## 1. Directory Structure as SSOT

### Question
Why is `docs/dir.md` the Single Source of Truth (SSOT) for the project structure?

### Answer
Infrastructure projects often suffer from "documentation drift" where the README doesn't match the actual file system. By maintaining a strict, annotated directory map in `docs/dir.md`, we achieve:
*   **Navigation**: A single entry point to find any component.
*   **Definition**: Explicitly defining the "Function", "Layer", and "Namespace" for each directory.
*   **Inventory**: Tracking planned components (e.g., L99 Apps) before they exist in code.

**Key Decision**:
The `docs/dir.md` file is the master registry. If a directory isn't listed there, it's not part of the official architecture.

---

## 2. The Necessity of Vault (Two-Tier Secret Management)

### Question 1: Do we need Vault if we already have GitHub/Digger Secrets?
### Question 2: Is Vault redundant ("stacking") over native K8s Secrets?

### Answer: The "Bootstrap vs. Runtime" Separation

We employ a **Two-Tier Secret Strategy** to solve different lifecycle problems:

#### Tier 1: Bootstrap Secrets (Infra-Ops Only)
*   **Tools**: GitHub Secrets / Terraform Variables / Digger Env.
*   **Lifecycle**: **"Building the House"**.
*   **Content**: R2 Credentials, VPS SSH Keys, Root Tokens.
*   **Why**: You need these *before* the cluster exists. You cannot store the key to create the cluster *inside* the cluster.

#### Tier 2: Runtime/Application Secrets (Dev + Ops)
*   **Tools**: **Vault** (SSOT + Policy + Audit) + **Vault Agent Injector** (delivery to Pods).
*   **Lifecycle**: **"Living in the House"**.
*   **Content**: Database passwords, Stripe Keys, API Tokens.
*   **Why**:
    *   **Vault** provides Versioned KV, RBAC/Policies, and Audit logging.
    *   **Injector** lets workloads read secrets at runtime without hardcoding or committing them to Git.
    *   **The "Stacking" Logic**: GitHub Secrets bootstrap the cluster; Vault manages runtime secrets lifecycle inside the cluster.

**Decision**:
*   **L1 (Bootstrap)** uses Terraform Variables/GitHub Secrets.
*   **L2+ (Apps/DBs)** uses Vault as the SSOT, injecting into Pods via Vault Agent Injector.
