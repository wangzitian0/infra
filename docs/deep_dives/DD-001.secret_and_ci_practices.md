# DD-001: Infrastructure Design Decisions & Deep Dives

This document captures key architectural Q&A and design rationale discussed during the initial infrastructure setup.

**Date**: 2025-12-06
**Topics**: SSOT, Atlantis, Secret Management Strategy

---

## 1. Directory Structure as SSOT

### Question
Why is `docs/dir.md` the Single Source of Truth (SSOT) for the project structure?

### Answer
Infrastructure projects often suffer from "documentation drift" where the README doesn't match the actual file system. By maintaining a strict, annotated directory map in `docs/dir.md`, we achieve:
*   **Navigation**: A single entry point to find any component.
*   **Definition**: Explicitly defining the "Function", "Layer", and "Namespace" for each directory.
*   **Inventory**: Tracking planned components (e.g., L99 Apps) before they exist in code.

**Key Decision**:
The `docs/dir.md` file is the master registry. If a directory isn't listed there, it's not part of the official architecture.

---

## 2. Atlantis Configuration: Helm Values vs. Env Vars

### Question
Why use `(Helm github.token)` in docs instead of a direct Environment Variable like `ATLANTIS_GH_TOKEN`?

### Answer
We chose the **Helm-native approach** over manual environment injection.

*   **Pros**:
    *   **Best Practice**: The `runatlantis/atlantis` chart handles sensitive data securely by creating K8s Secrets automatically.
    *   **Simplicity**: Directly maps to `values.yaml` schema (`github.token`), reducing boilerplate `env` blocks.
    *   **Automation**: The Chart may use this token for other internal setup (e.g. `.gitconfig` generation) that simple env vars might miss.
*   **Cons**:
    *   **Visibility**: It's less obvious than seeing `export TOKEN=...`.
    *   **Abstraction**: Requires knowing the Helm Chart's internal logic.

**Decision**: Use Helm's built-in `github.token` / `github.secret` for cleaner, more secure infrastructure code.

---

## 3. The Necessity of Infisical (Two-Tier Secret Management)

### Question 1: Do we need Infisical if we already have GitHub/Atlantis Secrets?
### Question 2: Is Infisical redundant ("stacking") over native K8s Secrets?

### Answer: The "Bootstrap vs. Runtime" Separation

We employ a **Two-Tier Secret Strategy** to solve different lifecycle problems:

#### Tier 1: Bootstrap Secrets (Infra-Ops Only)
*   **Tools**: GitHub Secrets / Terraform Variables / Atlantis Env.
*   **Lifecycle**: **"Building the House"**.
*   **Content**: R2 Credentials, VPS SSH Keys, Root Tokens.
*   **Why**: You need these *before* the cluster exists. You cannot store the key to create the cluster *inside* the cluster.

#### Tier 2: Runtime/Application Secrets (Dev + Ops)
*   **Tools**: **Infisical** (Control Plane) + **K8s Secrets** (Data Plane).
*   **Lifecycle**: **"Living in the House"**.
*   **Content**: Database passwords, Stripe Keys, API Tokens.
*   **Why**:
    *   **Infisical (Control Plane)** offers Versioning, RBAC, Click-to-Rollback, and Multi-Environment (Dev/Staging/Prod) isolation.
    *   **K8s Secrets (Data Plane)** are the raw storage mechanism K8s understands.
    *   **The "Stacking" Logic**: Infisical manages the *policy and lifecycle*; K8s Secrets provide the *runtime access*. This is like using **Git** (Version Control) to manage **Source Code Files** (Raw Data). You wouldn't manually edit raw files on a production server; similarly, you shouldn't manually edit raw K8s Secrets.

**Decision**:
*   **L1 (Bootstrap)** uses Terraform Variables/GitHub Secrets.
*   **L2+ (Apps/DBs)** uses Infisical as the SSOT, syncing to K8s Secrets via Operator.
