# Secrets Management Architecture

## Overview

Layered secrets management approach using GitHub Secrets for bootstrap and Infisical for application secrets.

## Architecture Layers

```
┌─────────────────────────────────────────┐
│     GitHub Secrets (Bootstrap Layer)    │
│  - VPS SSH Key                          │
│  - R2 Credentials (State Backend)       │
│  - PostgreSQL Password (Phase 1.1)      │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   Phase 0.0: k3s Cluster Bootstrap      │
│  - Deployed via Terraform + SSH         │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   Phase 0.1: Infisical                  │
│  (Secrets Management Platform)          │
│  ┌────────────────────────────────────┐ │
│  │ Infisical Backend                  │ │
│  │ - Encryption keys: Terraform rand  │ │
│  │ - JWT secrets: Terraform rand      │ │
│  └────────────────────────────────────┘ │
│  ┌────────────────────────────────────┐ │
│  │ MongoDB (embedded)                 │ │
│  │ - Password: Terraform random       │ │
│  │ - Storage: 20Gi PVC                │ │
│  └────────────────────────────────────┘ │
│  ┌────────────────────────────────────┐ │
│  │ Redis (embedded)                   │ │
│  │ - No auth (ClusterIP only)         │ │
│  │ - Storage: 10Gi PVC                │ │
│  └────────────────────────────────────┘ │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│   Phase 1.1: PostgreSQL                 │
│  (Shared Application Database)          │
│  - Password: GitHub Secret              │
│  - For: Kubero, future apps             │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Phase 2.x+: Application Services       │
│  - Passwords generated by Terraform     │
│  - Synced to Infisical for management   │
│  - Retrieved from Infisical at runtime  │
└─────────────────────────────────────────┘
```

## Phase Breakdown

### Phase 0.0: k3s Bootstrap

**Secrets Required:**
- VPS SSH Key (GitHub Secret: `VPS_SSH_KEY`)
- R2 credentials for Terraform state backend

**Purpose:**
- Deploy k3s cluster on VPS
- Establish kubeconfig for kubectl/helm access

### Phase 0.1: Infisical (Secrets Management)

**Purpose:** Centralized secrets management for Phase 2.x+ services

**Components:**
1. **Infisical Backend**
   - Encryption keys: Auto-generated by Terraform (`random_id`)
   - JWT secrets: Auto-generated by Terraform (`random_id`)
   - Admin account: Created manually in UI after deployment

2. **MongoDB (Embedded)**
   - Root password: Auto-generated by Terraform (`random_password`)
   - User password: Auto-generated by Terraform (`random_password`)
   - Storage: 20Gi persistent volume
   - Architecture: Standalone

3. **Redis (Embedded)**
   - No authentication (ClusterIP only, internal)
   - Storage: 10Gi persistent volume
   - Architecture: Standalone

4. **Mailhog (Embedded)**
   - Dev-only email testing
   - No authentication required

**Why Terraform-generated:**
- Infisical not yet available during its own deployment
- Terraform state acts as secure backup
- Rotation possible via Terraform re-apply

### Phase 0.2: Kubernetes Dashboard

**Purpose:** Cluster monitoring and management UI

**Secrets:**
- None required (uses ServiceAccount tokens)

### Phase 1.1: PostgreSQL (Application Database)

**Purpose:** Shared PostgreSQL instance for applications (Kubero, etc.)

**Secrets:**
- Password: `POSTGRES_PASSWORD` (GitHub Secret)
- Username: `infisical` (hardcoded)
- Database: `infisical` (hardcoded)

**Why GitHub Secret:**
- Critical infrastructure service
- Needs to be rotatable via CI/CD
- Required before other apps are deployed

### Phase 2.x+: Application Services (Future)

**Strategy:** Terraform + Infisical Integration

**Workflow:**
1. Terraform generates random password using `random_password`
2. Terraform creates secret in Infisical using `infisical_secret` resource
3. Terraform deploys application using the generated password
4. Application reads password from Infisical at runtime (optional)

**Example (Redis deployment):**
```hcl
# Generate password
resource "random_password" "redis" {
  length  = 32
  special = true
}

# Store in Infisical
resource "infisical_secret" "redis_password" {
  workspace_id = var.infisical_workspace_id
  secret_name  = "REDIS_PASSWORD"
  secret_value = random_password.redis.result
}

# Deploy Redis with password
resource "helm_release" "redis" {
  # ... chart config ...
  set_sensitive {
    name  = "auth.password"
    value = random_password.redis.result
  }
}
```

**Prerequisites:**
1. Deploy Phase 0.1 (Infisical)
2. Create workspace in Infisical UI
3. Generate API token with write permissions
4. Add to GitHub Secrets:
   - `INFISICAL_API_TOKEN`
   - `INFISICAL_WORKSPACE_ID`

## GitHub Secrets Required

### Phase 0.0 + 0.1 (Current)
```bash
# VPS Access
VPS_HOST=<ip-or-domain>
VPS_SSH_KEY=<private-key>
VPS_USER=root  # optional
VPS_SSH_PORT=22  # optional

# Terraform State Backend (R2)
AWS_ACCESS_KEY_ID=<r2-access-key>
AWS_SECRET_ACCESS_KEY=<r2-secret-key>
R2_BUCKET=<bucket-name>
R2_ACCOUNT_ID=<cloudflare-account-id>

# k3s Configuration
K3S_CLUSTER_NAME=truealpha-k3s  # optional
K3S_CHANNEL=stable  # optional
K3S_VERSION=  # optional
```

### Phase 1.1 (PostgreSQL)
```bash
# PostgreSQL Password
POSTGRES_PASSWORD=<strong-password>
```

### Phase 2.x+ (After Infisical deployed)
```bash
# Infisical Integration
INFISICAL_API_TOKEN=<api-token>
INFISICAL_WORKSPACE_ID=<workspace-id>
```

## Deployment Instructions

### Step 1: Deploy Phase 0.0 (k3s)

```bash
cd terraform
terraform init \
  -backend-config="bucket=$R2_BUCKET" \
  -backend-config="endpoints={s3=\"https://$R2_ACCOUNT_ID.r2.cloudflarestorage.com\"}"

terraform apply -target="null_resource.k3s_server" -var-file="staging.tfvars"
```

### Step 2: Deploy Phase 0.1 (Infisical)

```bash
terraform apply -target="helm_release.infisical" -var-file="staging.tfvars"
```

**Post-deployment:**
```bash
# Access Infisical UI
kubectl -n iac port-forward svc/infisical-backend 8080:8080

# Open in browser: http://localhost:8080
# 1. Create admin account
# 2. Create workspace (e.g., "truealpha-staging")
# 3. Generate API token (Settings → API Tokens)
# 4. Add to GitHub Secrets: INFISICAL_API_TOKEN, INFISICAL_WORKSPACE_ID
```

### Step 3: Deploy Phase 1.1 (PostgreSQL)

**Prerequisites:**
- Add `POSTGRES_PASSWORD` to GitHub Secrets

```bash
terraform apply -target="kubernetes_namespace.iac" -var-file="staging.tfvars"
terraform apply -target="helm_release.postgresql" -var-file="staging.tfvars"
```

### Step 4: Full Deployment

Once bootstrap phases are complete:
```bash
terraform apply -var-file="staging.tfvars"
```

## Access Infisical UI

After Phase 0.1 deployment:

```bash
# Port forward to access Infisical
kubectl -n iac port-forward svc/infisical-backend 8080:8080

# Open in browser: http://localhost:8080
```

**First-time setup:**
1. Create admin account
2. Create workspace (e.g., "truealpha-staging")
3. Generate API token (Settings → API Tokens)
4. Add token to GitHub Secrets as `INFISICAL_API_TOKEN`
5. Add workspace ID to GitHub Secrets as `INFISICAL_WORKSPACE_ID`

## Disaster Recovery

### Scenario: Lost Infisical Data

**Recovery Steps:**
1. Check Terraform state for passwords:
   ```bash
   terraform state show random_password.infisical_mongodb_root
   terraform state show random_password.infisical_mongodb_user
   ```

2. MongoDB data persists in PVC (unless deleted)

3. If PVC lost, re-apply Infisical resources:
   ```bash
   terraform apply -target=helm_release.infisical
   ```

### Scenario: Lost PostgreSQL Password

**Recovery Steps:**
1. Check GitHub Secrets for `POSTGRES_PASSWORD`
2. If lost, reset:
   ```bash
   # Generate new password
   # Update GitHub Secret: POSTGRES_PASSWORD
   # Re-apply: terraform apply -target=helm_release.postgresql
   ```

## Security Best Practices

### Do's
✅ Use GitHub Secrets for bootstrap credentials
✅ Use Terraform `random_password` for service passwords
✅ Rotate passwords via Terraform re-apply
✅ Use Infisical for Phase 2.x+ services
✅ Keep sensitive values in Terraform state (stored in R2)
✅ Use strong passwords (32+ characters, mixed case, special chars)

### Don'ts
❌ Hardcode passwords in code
❌ Commit secrets to git
❌ Use default passwords (`CHANGE_ME`)
❌ Share secrets via insecure channels
❌ Skip rotation of compromised secrets
❌ Store secrets in plaintext files

## Future Improvements

### Phase 2.x Implementation
- [ ] Add Infisical Terraform provider
- [ ] Implement password generation + sync pattern
- [ ] Configure applications to read from Infisical

### Phase 3.x+ Integration
- [ ] External Secrets Operator (auto-sync to k8s secrets)
- [ ] Vault integration (enterprise option)
- [ ] Secret rotation automation

### Observability
- [ ] Audit logging for secret access
- [ ] Alerting on secret changes
- [ ] Compliance reporting

## References

- [Infisical Terraform Provider](https://registry.terraform.io/providers/Infisical/infisical/latest/docs)
- [Terraform Random Provider](https://registry.terraform.io/providers/hashicorp/random/latest/docs)
- [GitHub Actions Secrets](https://docs.github.com/en/actions/security-guides/encrypted-secrets)
- [Infisical Documentation](https://infisical.com/docs)
