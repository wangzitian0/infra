# L3 Business PostgreSQL
#
# Purpose: PostgreSQL for business applications (L4)
# Password: Read from L2 terraform_remote_state (generated by L2, stored in Vault + state)
#
# Pattern: Bitnami Helm chart (matches L1 platform_pg)
# Note: Bitnami deletes old image tags, so we use 'latest' with IfNotPresent
#
# Consumers:
# - L4 Apps: business data storage
# - L2 Vault: dynamic credential generation
#
# Namespace: singular 'data' (not per-env) because:
# - L2 Vault database engine is singleton, expects postgresql.data.svc
# - Single VPS MVP doesn't need DB-level env isolation
# - L4 apps handle env isolation at app layer
#
# Architecture:
# L2 generates password â†’ outputs to state + Vault KV
# L3 reads from L2 remote_state (no Vault token needed!)

# =============================================================================
# Namespace (singular 'data' - L2 Vault connection expects this)
# =============================================================================

resource "kubernetes_namespace" "data" {
  metadata {
    name = "data"
    labels = {
      layer = "L3"
    }
  }
}

# =============================================================================
# Read Password from L2 Platform State (via terraform_remote_state)
# This eliminates the need for Vault provider/token in L3!
# =============================================================================

data "terraform_remote_state" "platform" {
  backend = "s3"

  config = {
    bucket                      = var.r2_bucket
    key                         = "k3s/platform.tfstate"
    region                      = "auto"
    skip_credentials_validation = true
    skip_metadata_api_check     = true
    skip_region_validation      = true
    skip_requesting_account_id  = true
    skip_s3_checksum            = true
    endpoints = {
      s3 = "https://${var.r2_account_id}.r2.cloudflarestorage.com"
    }
  }
}

locals {
  # Password from L2 remote_state (generated by L2, stored in Vault + state)
  postgres_password = data.terraform_remote_state.platform.outputs.l3_postgres_password
}

# =============================================================================
# PostgreSQL via Bitnami Helm chart (matches L1 pattern)
# =============================================================================

resource "helm_release" "postgresql" {
  name             = "postgresql"
  namespace        = kubernetes_namespace.data.metadata[0].name
  repository       = "oci://registry-1.docker.io/bitnamicharts"
  chart            = "postgresql"
  version          = "16.4.2"
  create_namespace = false
  timeout          = 300
  wait             = true
  wait_for_jobs    = true

  values = [
    yamlencode({
      # Bitnami deletes old tags; use latest + IfNotPresent to reduce drift
      image = {
        tag        = "latest"
        pullPolicy = "IfNotPresent"
      }
      auth = {
        postgresPassword = local.postgres_password
        database         = "app"
      }
      primary = {
        persistence = {
          enabled      = true
          storageClass = "local-path-retain"
          size         = "10Gi"
        }
        resources = {
          limits = {
            cpu    = "500m"
            memory = "512Mi"
          }
          requests = {
            cpu    = "100m"
            memory = "128Mi"
          }
        }
      }
    })
  ]
}

# =============================================================================
# Outputs
# =============================================================================

output "postgres_host" {
  value       = "postgresql.data.svc.cluster.local"
  description = "PostgreSQL K8s service DNS"
}

output "postgres_vault_path" {
  value       = "secret/data/postgres"
  description = "Vault KV path for PostgreSQL credentials"
}

output "postgres_namespace" {
  value       = "data"
  description = "Namespace where PostgreSQL is deployed"
}
