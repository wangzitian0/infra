name: Deploy k3s to VPS

on:
  push:
    branches: [main]
    paths:
      - "1.bootstrap/**"
      - "2.platform/**"
      - "3.data/**"
      - "4.apps/**"
      - ".github/workflows/deploy-k3s.yml"
      - ".github/actions/**"
  workflow_dispatch: {}

env:
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      # =========================================================
      # 1. Bootstrap Layer (L1): K3s, Atlantis, Cert-Manager
      # =========================================================
      - name: Setup Terraform Environment (L1)
        uses: ./.github/actions/terraform-setup
        with:
          working_directory: "1.bootstrap"
          terraform_version: 1.6.6
          tf_state_key: "k3s/terraform.tfstate"
          secrets_json: ${{ toJSON(secrets) }}

      - name: Pre-flight Check (Helm URLs)
        run: |
          chmod +x 0.tools/preflight-check.sh
          0.tools/preflight-check.sh

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.28.4

      - name: Import Existing Resources
        working-directory: 1.bootstrap
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          if ! terraform state show kubernetes_config_map_v1.local_path_config 2>/dev/null; then
            terraform import kubernetes_config_map_v1.local_path_config kube-system/local-path-config || true
          fi
          if ! terraform state show helm_release.atlantis 2>/dev/null; then
            terraform import helm_release.atlantis bootstrap/atlantis || true
          fi
          
      - name: Pre-flight (3-State Consistency)
        working-directory: 1.bootstrap
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          TF_HAS_ATLANTIS=$(terraform state show helm_release.atlantis 2>/dev/null && echo "yes" || echo "no")
          HELM_HAS_ATLANTIS=$(helm status atlantis -n bootstrap 2>/dev/null && echo "yes" || echo "no")
          if [ "$HELM_HAS_ATLANTIS" = "yes" ] && [ "$TF_HAS_ATLANTIS" = "no" ]; then
            kubectl -n bootstrap get secrets -o name | grep "sh.helm.release.v1.atlantis" | xargs -r kubectl -n bootstrap delete || true
            kubectl delete deployment -n bootstrap atlantis 2>/dev/null || true
          elif [ "$HELM_HAS_ATLANTIS" = "no" ] && [ "$TF_HAS_ATLANTIS" = "yes" ]; then
            terraform state rm helm_release.atlantis || true
          fi

      - name: Apply Infrastructure (L1)
        working-directory: 1.bootstrap
        run: terraform apply -auto-approve

      - name: Verify L1 (Smoke Test)
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          set -euo pipefail
          kubectl get nodes -o wide
          kubectl -n cert-manager rollout status deployment/cert-manager --timeout=180s
          kubectl -n bootstrap wait --for=condition=Ready pod/atlantis-0 --timeout=180s

      # =========================================================
      # 2. Platform Layer (L2): Vault, Observability, Ingress
      # =========================================================
      - name: Setup Terraform Environment (L2)
        uses: ./.github/actions/terraform-setup
        with:
          working_directory: "2.platform"
          terraform_version: 1.6.6
          tf_state_key: "k3s/platform.tfstate"
          secrets_json: ${{ toJSON(secrets) }}

      - name: Pre-flight (2-Vault Dependencies)
        run: |
          VAULT_URL="https://secrets.${INTERNAL_DOMAIN:-$BASE_DOMAIN}"
          HEALTH_RESPONSE=$(curl -sf --connect-timeout 10 "${VAULT_URL}/v1/sys/health" 2>&1 || echo "FAIL")
          if [ "$HEALTH_RESPONSE" = "FAIL" ] || echo "$HEALTH_RESPONSE" | grep -q "^<"; then
            echo "::error::Vault unreachable or returned HTML at ${VAULT_URL}"
            exit 1
          fi
          TOKEN_RESPONSE=$(curl -s --connect-timeout 10 -H "X-Vault-Token: ${VAULT_ROOT_TOKEN}" "${VAULT_URL}/v1/auth/token/lookup-self" 2>&1)
          if echo "$TOKEN_RESPONSE" | grep -qE "errors|^<"; then
            echo "::error::Vault token invalid or blocked by SSO"
            exit 1
          fi

      - name: Apply Infrastructure (L2 - Platform)
        working-directory: 2.platform
        run: |
          terraform workspace select default || terraform workspace new default
          terraform apply -auto-approve

      - name: Verify L2 (Vault Status)
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl -n platform wait --for=condition=Ready pod -l app.kubernetes.io/name=vault --timeout=180s
          kubectl -n platform exec "$(kubectl -n platform get pods -l app.kubernetes.io/name=vault -o jsonpath='{.items[0].metadata.name}')" -- vault status

      # =========================================================
      # 3. Data Layer (L3): Databases
      # =========================================================
      - name: Setup Terraform Environment (L3)
        uses: ./.github/actions/terraform-setup
        with:
          working_directory: "3.data"
          terraform_version: 1.6.6
          tf_state_key: "k3s/data-prod.tfstate"
          secrets_json: ${{ toJSON(secrets) }}

      - name: Apply Infrastructure (L3 - Data)
        if: github.event_name == 'push'
        working-directory: 3.data
        run: |
          terraform workspace select prod || terraform workspace new prod
          terraform apply -auto-approve

      - name: Verify Data Services Health (L3)
        if: github.event_name == 'push'
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          set -euo pipefail
          NS="data-prod"
          kubectl wait --for=condition=Ready pod -n "${NS}" --all --timeout=180s
          kubectl exec -n "${NS}" postgresql-0 -- pg_isready -U postgres

      # =========================================================
      # 4. App Layer (L4): Applications
      # =========================================================
      - name: Setup Terraform Environment (L4)
        uses: ./.github/actions/terraform-setup
        with:
          working_directory: "4.apps"
          terraform_version: 1.6.6
          tf_state_key: "k3s/apps-prod.tfstate"
          secrets_json: ${{ toJSON(secrets) }}

      - name: Apply Infrastructure (L4 - Apps)
        if: github.event_name == 'push'
        working-directory: 4.apps
        env:
          TF_VAR_environment: prod
        run: |
          if ls *.tf 1> /dev/null 2>&1; then
            terraform workspace select prod || terraform workspace new prod
            terraform apply -auto-approve || {
               echo "::error::L4 Apps Apply failed."
               exit 1
            }
          fi

      - name: Verify L4 (Endpoint Check)
        if: github.event_name == 'push'
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          set -euo pipefail

          # Skip if L4 was skipped (no .tf files)
          if ! ls 4.apps/*.tf 1>/dev/null 2>&1; then
            echo "⏭️ Skipping L4 Verify: No apps deployed"
            exit 0
          fi
          
          echo "Verifying L4 Applications..."
          ENV="prod"
          OP_NS="kubero-operator-system-${ENV}"
          UI_NS="kubero-${ENV}"

          echo "=== L4 Verification Debug Info ==="
          echo "Operator NS: ${OP_NS}"
          echo "UI NS: ${UI_NS}"

          echo "Checking Kubero operator..."
          kubectl -n "${OP_NS}" rollout status deployment/kubero-operator-controller-manager --timeout=300s
          kubectl -n "${OP_NS}" get pods -o wide

          echo "Checking Kubero CR..."
          if ! kubectl -n "${UI_NS}" get kuberoes.application.kubero.dev kubero; then
            echo "::warning::Kubero CR not found in ${UI_NS} - may not be deployed yet"
          fi

          echo "Checking Kubero UI pods..."
          POD_COUNT=$(kubectl -n "${UI_NS}" get pods --no-headers 2>/dev/null | wc -l | tr -d ' ')
          echo "Pod count in ${UI_NS}: ${POD_COUNT}"
          
          if [ "${POD_COUNT}" -gt 0 ]; then
            kubectl -n "${UI_NS}" wait --for=condition=Ready pod --all --timeout=150s || {
              echo "::error::Kubero UI pod failed to become ready. Dumping diagnostics..."
              kubectl -n "${UI_NS}" get pods -o wide
              kubectl -n "${UI_NS}" describe pod -l app.kubernetes.io/name=kubero || kubectl -n "${UI_NS}" describe pods
              kubectl -n "${UI_NS}" get events --sort-by='.lastTimestamp'
              exit 1
            }
            kubectl -n "${UI_NS}" get pods -o wide
          else
            echo "::warning::No pods in ${UI_NS} - Kubero UI may not be fully deployed"
          fi
          
          kubectl -n "${UI_NS}" get ingress || echo "No ingress found (optional)"

      - name: Upload kubeconfig
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: ${{ env.KUBECONFIG_PATH }}