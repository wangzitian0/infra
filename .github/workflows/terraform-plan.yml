name: Terraform CI

on:
  pull_request:
    branches: [main]
    paths:
      - "1.bootstrap/**"
      - "2.platform/**"
      - "3.data/**"
      - "4.apps/**"
      - ".github/workflows/**"

# Cancel in-progress runs for same PR
concurrency:
  group: terraform-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.sha }}
  cancel-in-progress: true

env:
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

jobs:
  validate:
    name: CI Validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ============================================================
      # PRE-FLIGHT: Integrity and Security (from main)
      # ============================================================
      - name: Variable Integrity Check
        run: python3 0.tools/check_integrity.py

      - name: Verify Key Format (Strict)
        run: |
          echo "${{ secrets.ATLANTIS_GH_APP_KEY }}" > atlantis_key.pem
          echo "Checking key format..."
          if ! openssl rsa -in atlantis_key.pem -check -noout; then
            echo "::warning::ATLANTIS_GH_APP_KEY might be corrupted, using GITHUB_TOKEN fallback."
          fi
          rm atlantis_key.pem

      # ============================================================
      # STEP 1: Create skeleton comment FIRST (lock commit)
      # ============================================================
      # Generate App Token is bypassed due to OpenSSL compatibility issues
      # Using secrets.GITHUB_TOKEN directly for comment updates.

      - name: Create skeleton comment
        id: skeleton
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const sha = context.payload.pull_request.head.sha.substring(0, 7);
            const timestamp = new Date().toISOString().slice(11, 16) + ' UTC';
            const runUrl = "https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/actions/runs/" + context.runId;
            const prUrl = "https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/pull/" + context.payload.pull_request.number;
            const MARKER = "<!-- infra-flash-commit:" + sha + " -->";
            
            // Check if comment already exists
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });
            const existing = comments.data.find(c => c.body.includes(MARKER));
            
            // Full skeleton with all sections
            const skeleton = [
              MARKER,
              "## ‚ö° Commit `" + sha + "`",
              '',
              '<details><summary>üìñ Commands</summary>',
              '',
              '| Command | Description |',
              '|:--------|:------------|',
              '| `atlantis plan` | Re-run plan |',
              '| `atlantis apply` | Apply changes |',
              '| `atlantis unlock` | Unlock PR |',
              '',
              '</details>',
              '',
              '---',
              '',
              "### CI Validate ‚è≥ | [" + sha + "](" + runUrl + ") | " + timestamp,
              '',
              '‚è≥ Running checks...', 
              '',
              '---',
              '',
              '### Atlantis Actions',
              '',
              '<!-- atlantis-actions -->',
              '| Action | Commit | Trigger | Status | Output | Time |',
              '|:-------|:-------|:--------|:------:|:-------|:-----|',
              '<!-- /atlantis-actions -->',
              '',
              '---',
              '',
              '‚è≥ **Waiting for CI...**'
            ].join('\n');
            
            let commentId;
            if (existing) {
              // Preserve existing Atlantis action rows
              let body = skeleton;
              const actionsMatch = existing.body.match(/<!-- atlantis-actions -->([\s\S]*?)<!-- \/atlantis-actions -->/);
              if (actionsMatch && actionsMatch[1].trim()) {
                body = skeleton.replace(
                  /<!-- atlantis-actions -->\n\| Action[\s\S]*?<!-- \/atlantis-actions -->/,
                  "<!-- atlantis-actions -->\n| Action | Commit | Trigger | Status | Output | Time |\n|:-------|:-------|:--------|:------:|:-------|:-----|" + actionsMatch[1] + "<!-- /atlantis-actions -->"
                );
              }
              
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: body
              });
              commentId = existing.id;
            } else {
              const created = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: skeleton
              });
              commentId = created.data.id;
            }
            console.log("Created/updated skeleton for commit " + sha);
            return commentId.toString();

      # ============================================================
      # STEP 2: Run CI Checks
      # ============================================================
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
          terraform_wrapper: false

      - name: Format Check
        id: fmt
        run: terraform fmt -check -recursive -diff
        continue-on-error: true

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: TFLint (L1)
        id: lint_l1
        working-directory: 1.bootstrap
        run: tflint --init && tflint --recursive --minimum-failure-severity=error
        continue-on-error: true

      - name: TFLint (L2)
        id: lint_l2
        working-directory: 2.platform
        run: tflint --init && tflint --recursive --minimum-failure-severity=error
        continue-on-error: true

      - name: TFLint (L3)
        id: lint_l3
        working-directory: 3.data
        run: tflint --init && tflint --recursive --minimum-failure-severity=error
        continue-on-error: true

      - name: TFLint (L4)
        id: lint_l4
        working-directory: 4.apps
        run: tflint --init && tflint --recursive --minimum-failure-severity=error
        continue-on-error: true

      - name: Pre-flight Check (Helm URLs)
        run: |
          chmod +x 0.tools/preflight-check.sh
          0.tools/preflight-check.sh

      - name: Validate (L1)
        id: validate_l1
        working-directory: 1.bootstrap
        run: terraform init -backend=false -input=false -no-color && terraform validate -no-color
        continue-on-error: true

      - name: Validate (L2)
        id: validate_l2
        working-directory: 2.platform
        run: terraform init -backend=false -input=false -no-color && terraform validate -no-color
        continue-on-error: true

      - name: Validate (L3)
        id: validate_l3
        working-directory: 3.data
        run: terraform init -backend=false -input=false -no-color && terraform validate -no-color
        continue-on-error: true

      - name: Validate (L4)
        id: validate_l4
        working-directory: 4.apps
        run: terraform init -backend=false -input=false -no-color && terraform validate -no-color
        continue-on-error: true

      # ============================================================
      # STEP 3: Update comment with results
      # ============================================================
      - name: Update comment with results
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fmt = '${{ steps.fmt.outcome }}' || 'skipped';
            const lint_l1 = '${{ steps.lint_l1.outcome }}' || 'skipped';
            const lint_l2 = '${{ steps.lint_l2.outcome }}' || 'skipped';
            const lint_l3 = '${{ steps.lint_l3.outcome }}' || 'skipped';
            const lint_l4 = '${{ steps.lint_l4.outcome }}' || 'skipped';
            const validate_l1 = '${{ steps.validate_l1.outcome }}' || 'skipped';
            const validate_l2 = '${{ steps.validate_l2.outcome }}' || 'skipped';
            const validate_l3 = '${{ steps.validate_l3.outcome }}' || 'skipped';
            const validate_l4 = '${{ steps.validate_l4.outcome }}' || 'skipped';
            
            const icon = (s) => s === 'success' ? '‚úÖ' : (s === 'skipped' ? '‚è≠Ô∏è' : '‚ùå');
            const allPass = [fmt, lint_l1, lint_l2, lint_l3, lint_l4, validate_l1, validate_l2, validate_l3, validate_l4]
              .every(s => s === 'success' || s === 'skipped');
            const sha = context.payload.pull_request.head.sha.substring(0, 7);
            const timestamp = new Date().toISOString().slice(11, 16) + ' UTC';
            const runUrl = "https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/actions/runs/" + context.runId;
            const commentId = ${{ steps.skeleton.outputs.result }};
            const MARKER = "<!-- infra-flash-commit:" + sha + " -->";
            
            // Get existing comment
            const existingComment = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId
            });
            
            // CI section: simple if passed, detailed if failed
            let ciSection;
            if (allPass) {
              ciSection = "### CI Validate ‚úÖ | [" + sha + "](" + runUrl + ") | " + timestamp;
            } else {
              const fixCmd = '```bash\n# Fix locally:\nterraform fmt -recursive\nterraform validate\ngit push\n```';
              ciSection = [
                "### CI Validate ‚ùå | [" + sha + "](" + runUrl + ") | " + timestamp,
                '',
                '| Layer | Format | Lint | Validate |',
                '|:------|:------:|:----:|:--------:|',
                `| L1 Bootstrap | ${icon(fmt)} | ${icon(lint_l1)} | ${icon(validate_l1)} |`,
                `| L2 Platform | ${icon(fmt)} | ${icon(lint_l2)} | ${icon(validate_l2)} |`,
                `| L3 Data | ${icon(fmt)} | ${icon(lint_l3)} | ${icon(validate_l3)} |`,
                `| L4 Apps | ${icon(fmt)} | ${icon(lint_l4)} | ${icon(validate_l4)} |`,
                '',
                fixCmd
              ].join('\n');
            }
            
            // Check if TF files were changed (Atlantis only runs for TF changes)
            const changedFiles = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              per_page: 100
            });
            const hasTfChanges = changedFiles.data.some(f => 
              /^[1-4]\.(bootstrap|platform|data|apps)\/.*\.tf$/.test(f.filename)
            );
            
            // Next step depends on CI result AND whether TF files changed
            let nextStep;
            if (!allPass) {
              nextStep = '‚ùå **CI failed.** Fix errors and push again.';
            } else if (hasTfChanges) {
              nextStep = '‚è≥ **Atlantis autoplan running...**';
            } else {
              nextStep = '‚úÖ **No Terraform changes. Ready to merge!**';
            }
            
            // Preserve Atlantis actions
            let atlantisSection = [
              '<!-- atlantis-actions -->',
              '| Action | Commit | Trigger | Status | Output | Time |',
              '|:-------|:-------|:--------|:------:|:-------|:-----|',
              '<!-- /atlantis-actions -->'
            ].join('\n');
            
            const actionsMatch = existingComment.data.body.match(/<!-- atlantis-actions -->([\s\S]*?)<!-- \/atlantis-actions -->/);
            if (actionsMatch && actionsMatch[1].includes('|')) {
              atlantisSection = "<!-- atlantis-actions -->" + actionsMatch[1] + "<!-- /atlantis-actions -->";
            }
            
            // Build final body
            const body = [
              MARKER,
              "## ‚ö° Commit `" + sha + "`",
              '',
              '<details><summary>üìñ Commands</summary>',
              '',
              '| Command | Description |',
              '|:--------|:------------|',
              '| `atlantis plan` | Re-run plan |',
              '| `atlantis apply` | Apply changes |',
              '| `atlantis unlock` | Unlock PR |',
              '',
              '</details>',
              '',
              '---',
              '',
              ciSection,
              '',
              '---',
              '',
              '### Atlantis Actions',
              '',
              atlantisSection,
              '',
              '---',
              '',
              nextStep
            ].join('\n');
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: body
            });
            console.log("Updated comment: CI " + (allPass ? 'PASS' : 'FAIL'));

      # ============================================================
      # Final Status
      # ============================================================
      - name: Check Results
        run: |
          FAILED=0
          [[ "${{ steps.fmt.outcome }}" != "success" ]] && echo "‚ùå Format check failed" && FAILED=1
          [[ "${{ steps.lint_l1.outcome }}" != "success" ]] && echo "‚ùå L1 lint failed" && FAILED=1
          [[ "${{ steps.lint_l2.outcome }}" != "success" ]] && echo "‚ùå L2 lint failed" && FAILED=1
          [[ "${{ steps.lint_l3.outcome }}" != "success" ]] && echo "‚ùå L3 lint failed" && FAILED=1
          [[ "${{ steps.lint_l4.outcome }}" != "success" ]] && echo "‚ùå L4 lint failed" && FAILED=1
          [[ "${{ steps.validate_l1.outcome }}" != "success" ]] && echo "‚ùå L1 validate failed" && FAILED=1
          [[ "${{ steps.validate_l2.outcome }}" != "success" ]] && echo "‚ùå L2 validate failed" && FAILED=1
          [[ "${{ steps.validate_l3.outcome }}" != "success" ]] && echo "‚ùå L3 validate failed" && FAILED=1
          [[ "${{ secrets.GITHUB_TOKEN == '' }}" == "true" ]] && echo "‚ùå GITHUB_TOKEN is empty" && FAILED=1
          [[ "${{ steps.validate_l4.outcome }}" != "success" ]] && echo "‚ùå L4 validate failed" && FAILED=1
          
          if [[ $FAILED -eq 1 ]]; then
            echo "::error::CI validation failed"
            exit 1
          fi
          echo "‚úÖ All CI checks passed"
