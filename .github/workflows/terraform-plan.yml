name: Terraform CI

on:
  pull_request:
    branches: [main]
    paths:
      - "0.tools/**"
      - "1.bootstrap/**"
      - "2.platform/**"
      - "envs/**/3.data/**"
      - "4.apps/**"
      - ".github/workflows/**"

# Cancel in-progress runs for same PR
concurrency:
  group: terraform-${{ github.event.pull_request.number }}-${{ github.event.pull_request.head.sha }}
  cancel-in-progress: true

env:
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

jobs:
  validate:
    name: CI Validate
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ============================================================
      # PRE-FLIGHT: Integrity and Security
      # ============================================================
      - name: Variable Integrity Check
        run: python3 0.tools/check_integrity.py

      - name: Verify Key Format (Strict)
        run: |
          echo "${{ secrets.ATLANTIS_GH_APP_KEY }}" > atlantis_key.pem
          echo "Checking key format..."
          if ! openssl rsa -in atlantis_key.pem -check -noout; then
            echo "::error::ATLANTIS_GH_APP_KEY is corrupted in CI environment!"
            exit 1
          fi
          echo "‚úÖ Key format is valid."
          rm atlantis_key.pem

      - name: Generate App Token
        id: app_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.ATLANTIS_GH_APP_ID }}
          private-key: ${{ secrets.ATLANTIS_GH_APP_KEY }}

      - name: Create skeleton comment
        id: skeleton
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          result-encoding: string
          script: |
            const sha = context.payload.pull_request.head.sha.substring(0, 7);
            const timestamp = new Date().toISOString().slice(11, 16) + ' UTC';
            const runUrl = "https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/actions/runs/" + context.runId;
            const prUrl = "https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/pull/" + context.payload.pull_request.number;
            const MARKER = "<!-- infra-flash-commit:" + sha + " -->";
            
            // Check if comment already exists
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });
            const existing = comments.data.find(c => c.body.includes(MARKER));
            
            const commandHelp = [
              '<details><summary>üìñ Available Infra Commands</summary>',
              '',
              '| Command | Description | Feedback |',
              '|:---|:---|:---|',
              '| `atlantis plan` | Re-run infrastructure plan | Append to this table |',
              '| `atlantis apply` | Deploy changes | Append to this table |',
              '| `@claude review this` | AI Code Review | New comment reply |',
              '| `infra dig` | Service Health Check | Append to dashboard |',
              '| `infra help` | Show detailed help | New reply |',
              '',
              '</details>'
            ].join('\n');

            // Full skeleton with Status Table (matches ops.pipeline.md Dashboard Schema)
            const skeleton = [
              MARKER,
              "## ‚ö° Commit `" + sha + "` Dashboard",
              "",
              "| Stage | Status | Link | Time |",
              "|:---|:---:|:---|:---|",
              `| Static CI | ‚è≥ | [Running...](${runUrl}) | ${timestamp} |`,
              "| Infra Plan | ‚è≥ | Pending | - |",
              "| Infra Apply | ‚è≠Ô∏è | - | - |",
              "| AI Review | ‚è≠Ô∏è | - | - |",
              "",
              "<details><summary>üìú Action History</summary>",
              "",
              "| Action | Trigger | Output | Time |",
              "|:---|:---|:---|:---|",
              "<!-- history-rows -->",
              "",
              "</details>",
              "",
              commandHelp,
              "",
              "<!-- next-step -->",
              "‚è≥ Waiting for CI...",
              "<!-- /next-step -->"
            ].join('\n');
            
            let commentId;
            if (existing) {
              // Preserve existing history rows
              let body = skeleton;
              const historyMatch = existing.body.match(/<!-- history-rows -->([\s\S]*?)<\/details>/);
              if (historyMatch && historyMatch[1].trim()) {
                // Keep existing history rows (they're added before the marker)
                const rows = historyMatch[1].split('\n').filter(r => r.startsWith('|')).join('\n');
                if (rows) {
                  body = body.replace('<!-- history-rows -->', rows + '\n<!-- history-rows -->');
                }
              }

              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: body
              });
              commentId = existing.id;
            } else {
              const created = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: skeleton
              });
              commentId = created.data.id;
            }
            console.log("Created/updated skeleton for commit " + sha);
            return commentId.toString();

      # ============================================================
      # STEP 2: Run CI Checks
      # ============================================================
      - name: Determine TF Version
        id: tf_version
        run: echo "version=$(cat .terraform-version | tr -d '[:space:]')" >> $GITHUB_OUTPUT

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ steps.tf_version.outputs.version }}
          terraform_wrapper: false

      - name: Format Check
        id: fmt
        run: terraform fmt -check -recursive -diff
        continue-on-error: true

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: TFLint (L1)
        id: lint_l1
        working-directory: 1.bootstrap
        run: tflint --init && tflint --recursive --minimum-failure-severity=error
        continue-on-error: true

      - name: TFLint (L2)
        id: lint_l2
        working-directory: 2.platform
        run: tflint --init && tflint --recursive --minimum-failure-severity=error
        continue-on-error: true

      # L3: Skipped - now managed in envs/staging/3.data and envs/prod/3.data
      # TFLint would need to run against both directories separately
      - name: TFLint (L3)
        id: lint_l3
        run: echo "Skipped - L3 now uses directory-based isolation (envs/*/3.data/)"
        continue-on-error: true

      - name: TFLint (L4)
        id: lint_l4
        working-directory: 4.apps
        run: tflint --init && tflint --recursive --minimum-failure-severity=error
        continue-on-error: true

      - name: Pre-flight Check (Helm URLs)
        run: |
          chmod +x 0.tools/preflight-check.sh
          0.tools/preflight-check.sh

      - name: Validate (L1)
        id: validate_l1
        working-directory: 1.bootstrap
        run: terraform init -backend=false -input=false -no-color && terraform validate -no-color
        continue-on-error: true

      # L2/L3/L4: Skipped - now managed by Terragrunt
      # terraform validate requires providers.tf/backend.tf which are auto-generated by Terragrunt (gitignored)
      # Atlantis will validate these during plan/apply with Terragrunt
      - name: Validate (L2)
        id: validate_l2
        run: echo "Skipped - L2 now uses Terragrunt (providers/backend auto-generated)"
        continue-on-error: true

      - name: Validate (L3)
        id: validate_l3
        run: echo "Skipped - L3 now uses Terragrunt + directory isolation (envs/*/3.data/)"
        continue-on-error: true

      - name: Validate (L4)
        id: validate_l4
        run: echo "Skipped - L4 now uses Terragrunt (providers/backend auto-generated)"
        continue-on-error: true

      # ========================================== 
      # STEP 3: Update comment with results
      # ========================================== 
      - name: Update comment with results
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const fmt = '${{ steps.fmt.outcome }}' || 'skipped';
            const lint_l1 = '${{ steps.lint_l1.outcome }}' || 'skipped';
            const lint_l2 = '${{ steps.lint_l2.outcome }}' || 'skipped';
            const lint_l3 = '${{ steps.lint_l3.outcome }}' || 'skipped';
            const lint_l4 = '${{ steps.lint_l4.outcome }}' || 'skipped';
            const validate_l1 = '${{ steps.validate_l1.outcome }}' || 'skipped';
            const validate_l2 = '${{ steps.validate_l2.outcome }}' || 'skipped';
            const validate_l3 = '${{ steps.validate_l3.outcome }}' || 'skipped';
            const validate_l4 = '${{ steps.validate_l4.outcome }}' || 'skipped';
            
            const icon = (s) => s === 'success' ? '‚úÖ' : (s === 'skipped' ? '‚è≠Ô∏è' : '‚ùå');
            const allPass = [fmt, lint_l1, lint_l2, lint_l3, lint_l4, validate_l1, validate_l2, validate_l3, validate_l4]
              .every(s => s === 'success' || s === 'skipped');
            const sha = context.payload.pull_request.head.sha.substring(0, 7);
            const timestamp = new Date().toISOString().slice(11, 16) + ' UTC';
            const runUrl = "https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/actions/runs/" + context.runId;
            const commentId = ${{ steps.skeleton.outputs.result }};
            const MARKER = "<!-- infra-flash-commit:" + sha + " -->";
            
            // Get existing comment
            const existingComment = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId
            });
            
            // CI section: only show error link if failed
            let ciDetails = "";
            let statusIcon = allPass ? '‚úÖ' : '‚ùå';
            if (!allPass) {
              ciDetails = [
                '---',
                `### ‚ùå Static CI Failed`,
                `> Detailed logs and fix commands: [View Run Log](${runUrl})`,
                '---'
              ].join('\n');
            }
            
            // Check if TF files were changed
            const changedFiles = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              per_page: 100
            });
            const hasTfChanges = changedFiles.data.some(f =>
              /^([1-4]\.(bootstrap|platform|apps)\/.*\.tf$|envs\/.*\/3\.data\/.*\.tf$)/.test(f.filename)
            );
            
            // Next step message (concise, matches ops.pipeline.md style)
            let nextStep;
            if (!allPass) {
              nextStep = '‚ùå CI failed. Fix errors and push again.';
            } else if (hasTfChanges) {
              nextStep = '‚è≥ Waiting for Atlantis autoplan...';
            } else {
              nextStep = '‚úÖ No TF changes. Ready to merge!';
            }

            let body = existingComment.data.body;

            // 1. Update Status Table Row for CI (matches ops.pipeline.md schema - no bold)
            body = body.replace(
              /\| Static CI \| .* \| .* \| .* \|/,
              `| Static CI | ${statusIcon} | [View](${runUrl}) | ${timestamp} |`
            );

            // 1.5 If no TF changes, mark Infra Plan/Apply as skipped
            if (!hasTfChanges) {
              body = body.replace(
                /\| Infra Plan \| .* \| .* \| .* \|/,
                `| Infra Plan | ‚è≠Ô∏è | No TF changes | - |`
              );
              body = body.replace(
                /\| Infra Apply \| .* \| .* \| .* \|/,
                `| Infra Apply | ‚è≠Ô∏è | - | - |`
              );
            }

            // 2. Update Next Step (matches ops.pipeline.md marker)
            body = body.replace(
              /<!-- next-step -->[\s\S]*?<!-- \/next-step -->/,
              `<!-- next-step -->\n${nextStep}\n<!-- /next-step -->`
            );

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: body
            });
            console.log("Updated comment: CI " + (allPass ? 'PASS' : 'FAIL'));

      # ============================================================
      # Final Status
      # ============================================================
      - name: Check Results
        run: |
          FAILED=0
          [[ "${{ steps.fmt.outcome }}" != "success" ]] && echo "‚ùå Format check failed" && FAILED=1
          [[ "${{ steps.lint_l1.outcome }}" != "success" ]] && echo "‚ùå L1 lint failed" && FAILED=1
          [[ "${{ steps.lint_l2.outcome }}" != "success" ]] && echo "‚ùå L2 lint failed" && FAILED=1
          [[ "${{ steps.lint_l3.outcome }}" != "success" ]] && echo "‚ùå L3 lint failed" && FAILED=1
          [[ "${{ steps.lint_l4.outcome }}" != "success" ]] && echo "‚ùå L4 lint failed" && FAILED=1
          [[ "${{ steps.validate_l1.outcome }}" != "success" ]] && echo "‚ùå L1 validate failed" && FAILED=1
          [[ "${{ steps.validate_l2.outcome }}" != "success" ]] && echo "‚ùå L2 validate failed" && FAILED=1
          [[ "${{ steps.validate_l3.outcome }}" != "success" ]] && echo "‚ùå L3 validate failed" && FAILED=1
          [[ "${{ steps.validate_l4.outcome }}" != "success" ]] && echo "‚ùå L4 validate failed" && FAILED=1
          
          if [[ $FAILED -eq 1 ]]; then
            echo "::error::CI validation failed"
            exit 1
          fi
          echo "‚úÖ All CI checks passed"