# Bootstrap Layer Deployment
# Purpose: Independent Terraform workflow for Bootstrap (L1) layer
# 
# Why separate from Digger?
# Bootstrap contains the Digger Orchestrator itself - can't use Digger to deploy Digger.
# This workflow runs native Terraform directly.

name: Bootstrap Deploy

on:
  # Post-merge: auto apply
  push:
    branches: [main]
  
  # PR comment commands
  issue_comment:
    types: [created]
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - plan
          - apply

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  TF_VERSION: "1.11.0"
  WORKING_DIR: bootstrap
  TF_STATE_KEY: "k3s/terraform.tfstate"

jobs:
  # =============================================================
  # Command Handler: /bootstrap plan, /bootstrap apply
  # =============================================================
  command:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      (contains(github.event.comment.body, '/bootstrap plan') ||
       contains(github.event.comment.body, '/bootstrap apply'))
    outputs:
      action: ${{ steps.parse.outputs.action }}
      pr_number: ${{ github.event.issue.number }}
    steps:
      - name: Parse Command
        id: parse
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          if [[ "$COMMENT_BODY" == *"/bootstrap apply"* ]]; then
            echo "action=apply" >> $GITHUB_OUTPUT
          else
            echo "action=plan" >> $GITHUB_OUTPUT
          fi

      - name: React to Comment
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

  # =============================================================
  # Terraform Plan/Apply
  # =============================================================
  terraform:
    runs-on: ubuntu-latest
    needs: [command]
    if: |
      always() &&
      (github.event_name == 'push' ||
       github.event_name == 'workflow_dispatch' ||
       (needs.command.result == 'success'))
    concurrency:
      group: bootstrap-${{ github.event_name == 'push' && 'apply' || needs.command.outputs.action || github.event.inputs.action }}
      cancel-in-progress: false  # Never cancel infrastructure operations
    
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'issue_comment' && format('refs/pull/{0}/head', needs.command.outputs.pr_number) || github.ref }}

      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}

      # Set PR commit status so workflow appears in PR checks
      - name: Set PR Status (Pending)
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ needs.command.outputs.pr_number }}
            });
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: pr.data.head.sha,
              state: 'pending',
              context: 'Bootstrap Deploy',
              description: '${{ needs.command.outputs.action }} in progress...',
              target_url: `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}
          tf_state_key: ${{ env.TF_STATE_KEY }}
          working_directory: ${{ env.WORKING_DIR }}

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set +e
          terraform plan -input=false -no-color -detailed-exitcode -out=tfplan 2>&1 | tee plan.txt
          PLAN_EXITCODE=${PIPESTATUS[0]}
          set -e
          if [ "$PLAN_EXITCODE" -eq 1 ]; then
            exit 1
          fi
          echo "plan_exitcode=$PLAN_EXITCODE" >> $GITHUB_OUTPUT
          echo "plan_output<<EOF" >> $GITHUB_OUTPUT
          cat plan.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post Plan to PR
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        env:
          PLAN_OUTPUT: ${{ steps.plan.outputs.plan_output }}
          PR_NUMBER: ${{ needs.command.outputs.pr_number }}
          ACTION: ${{ needs.command.outputs.action }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const planOutput = (process.env.PLAN_OUTPUT || '').substring(0, 60000);
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const action = process.env.ACTION;

            const bodyLines = [
              '### üîß Bootstrap Terraform Plan',
              '',
              '<details>',
              '<summary>ÁÇπÂáªÂ±ïÂºÄ Plan ËæìÂá∫</summary>',
              '',
              '```hcl',
              planOutput,
              '```',
              '</details>',
            ];

            if (action === 'plan') {
              bodyLines.push('', '> To apply: comment `/bootstrap apply`');
            } else {
              bodyLines.push('', '> **Applying changes...** ‚è≥');
            }

            const body = bodyLines.join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });

      - name: Determine if Apply
        id: should-apply
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "${{ steps.plan.outputs.plan_exitcode }}" == "2" ]]; then
              echo "apply=true" >> $GITHUB_OUTPUT
            else
              echo "apply=false" >> $GITHUB_OUTPUT
            fi
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.action }}" == "apply" ]]; then
            echo "apply=true" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.command.outputs.action }}" == "apply" ]]; then
            echo "apply=true" >> $GITHUB_OUTPUT
          else
            echo "apply=false" >> $GITHUB_OUTPUT
          fi

      - name: Adopt Existing Bootstrap Resources
        if: steps.should-apply.outputs.apply == 'true'
        shell: bash
        working-directory: ${{ env.WORKING_DIR }}
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          set -euo pipefail

          if ! command -v kubectl >/dev/null 2>&1; then
            echo "kubectl not found; installing..."
            curl -sLo /usr/local/bin/kubectl \
              "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x /usr/local/bin/kubectl
          fi

          STATE_LIST="$(terraform state list || true)"
          in_state() { echo "$STATE_LIST" | grep -qx "$1"; }

          import_if_exists() {
            local addr="$1"
            local id="$2"
            local check_cmd="$3"

            if in_state "$addr"; then
              echo "‚úÖ ${addr} already in state"
              return 0
            fi

            if eval "$check_cmd"; then
              echo "üîÅ Importing ${addr} (${id})"
              terraform import -input=false "$addr" "$id"
            else
              echo "‚ÑπÔ∏è ${addr} not found in cluster, skipping import"
            fi
          }

          find_helm_release_ns() {
            local name="$1"
            kubectl get secret -A -o jsonpath='{range .items[*]}{.metadata.namespace}{"\t"}{.metadata.name}{"\n"}{end}' \
              | awk -v pattern="^sh\\.helm\\.release\\.v1\\.${name}\\.v" '$2 ~ pattern {print $1; exit}'
          }

          import_helm_release() {
            local addr="$1"
            local name="$2"
            local ns

            if in_state "$addr"; then
              echo "‚úÖ ${addr} already in state"
              return 0
            fi

            ns="$(find_helm_release_ns "$name")"
            if [[ -z "$ns" ]]; then
              echo "‚ÑπÔ∏è Helm release ${name} not found in cluster, skipping import"
              return 0
            fi

            echo "üîÅ Importing ${addr} (${ns}/${name})"
            terraform import -input=false "$addr" "${ns}/${name}"
          }

          import_if_exists \
            "kubernetes_secret.platform_pg_superuser" \
            "platform/platform-pg-superuser" \
            "kubectl -n platform get secret platform-pg-superuser >/dev/null 2>&1"

          import_helm_release "helm_release.cnpg_operator" "cnpg"
          import_helm_release "helm_release.digger" "digger"

      - name: Terraform Plan (Post-Import)
        id: plan_post_import
        if: steps.should-apply.outputs.apply == 'true'
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          set +e
          terraform plan -input=false -no-color -detailed-exitcode -out=tfplan 2>&1 | tee plan.txt
          PLAN_EXITCODE=${PIPESTATUS[0]}
          set -e
          if [ "$PLAN_EXITCODE" -eq 1 ]; then
            exit 1
          fi
          echo "plan_exitcode=$PLAN_EXITCODE" >> $GITHUB_OUTPUT

      - name: Terraform Apply
        if: steps.should-apply.outputs.apply == 'true' && steps.plan_post_import.outputs.plan_exitcode == '2'
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform apply -input=false -auto-approve tfplan

      - name: Post Apply Verify (DNS/HTTPS)
        if: steps.should-apply.outputs.apply == 'true'
        shell: bash
        run: |
          set -euo pipefail
          DOMAIN="${INTERNAL_DOMAIN:-$BASE_DOMAIN}"
          if [ -z "$DOMAIN" ]; then
            echo "::error::INTERNAL_DOMAIN or BASE_DOMAIN is required for health checks."
            exit 1
          fi

          HOST="digger.${DOMAIN}"
          echo "üîé Checking DNS for ${HOST}..."
          for i in $(seq 1 30); do
            if getent hosts "${HOST}" >/dev/null 2>&1; then
              echo "‚úÖ DNS resolved for ${HOST}"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "::error::DNS resolution failed for ${HOST}"
              exit 1
            fi
            sleep 2
          done

          echo "üîé Checking HTTPS health..."
          for i in $(seq 1 15); do
            if curl -fsS --max-time 5 "https://${HOST}/health" >/dev/null; then
              echo "‚úÖ Digger health OK"
              exit 0
            fi
            sleep 4
          done
          echo "::error::Digger health not reachable at https://${HOST}/health"
          exit 1

      - name: Post Apply Result
        if: steps.should-apply.outputs.apply == 'true' && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ needs.command.outputs.pr_number }},
              body: '### ‚úÖ Bootstrap Apply Complete\n\nTerraform apply finished successfully.'
            });

      # Set PR commit status on success
      - name: Set PR Status (Success)
        if: success() && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ needs.command.outputs.pr_number }}
            });
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: pr.data.head.sha,
              state: 'success',
              context: 'Bootstrap Deploy',
              description: '${{ needs.command.outputs.action }} completed',
              target_url: `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

      - name: Post Failure Result
        if: failure() && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const runUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ needs.command.outputs.pr_number }},
              body: `### ‚ùå Bootstrap Apply Failed
              
              Check the [Workflow Run](${runUrl}) for details.`
            });

      # Set PR commit status on failure
      - name: Set PR Status (Failure)
        if: failure() && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ needs.command.outputs.pr_number }}
            });
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: pr.data.head.sha,
              state: 'failure',
              context: 'Bootstrap Deploy',
              description: '${{ needs.command.outputs.action }} failed',
              target_url: `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

      - name: Notify on Failure
        if: failure() && github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const runUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Bootstrap deploy failed',
              body: `Bootstrap layer deployment failed after merge.\n\n**Run**: ${runUrl}`,
              labels: ['bug', 'priority/high']
            });
