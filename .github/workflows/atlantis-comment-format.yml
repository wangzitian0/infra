name: Format Atlantis Comments

on:
  issue_comment:
    types: [created]

jobs:
  format:
    # Only process Atlantis plan/apply comments on PRs
    if: |
      github.event.issue.pull_request &&
      github.event.comment.user.login == 'infra-flash[bot]' &&
      (contains(github.event.comment.body, 'Ran Plan') ||
       contains(github.event.comment.body, 'Ran Apply'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write

    steps:
      - name: Generate App Token
        id: app_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.ATLANTIS_GH_APP_ID }}
          private-key: ${{ secrets.ATLANTIS_GH_APP_KEY }}

      - name: Format comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const commentId = context.payload.comment.id;
            const body = context.payload.comment.body;
            const prNumber = context.payload.issue.number;

            const isPlan = body.includes('Ran Plan');
            const isApply = body.includes('Ran Apply');
            const stage = isPlan ? 'Plan' : 'Apply';

            // Find trigger comment
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100
            });

            const atlantisTime = new Date(context.payload.comment.created_at);
            const triggerComment = comments
              .filter(c => new Date(c.created_at) < atlantisTime)
              .filter(c => (c.body || '').toLowerCase().includes(`atlantis ${stage.toLowerCase()}`))
              .pop();

            // Extract location info from header: "Ran Plan for project: `xxx` dir: `xxx` workspace: `xxx`"
            const projectMatch = body.match(/project: `([^`]+)`/);
            const dirMatch = body.match(/dir: `([^`]+)`/);
            const workspaceMatch = body.match(/workspace: `([^`]+)`/);

            const project = projectMatch ? projectMatch[1] : 'unknown';
            const dir = dirMatch ? dirMatch[1] : 'unknown';
            const workspace = workspaceMatch ? workspaceMatch[1] : 'default';

            // Check for success/error - prioritize success indicators over error patterns
            // IMPORTANT: terragrunt WARN messages should not cause false failures
            const applyComplete = /Apply complete!/i.test(body);
            const planComplete = /Plan:.*to (add|import|change|destroy)/i.test(body);
            const hasExplicitError = /\*\*(Plan|Apply) Error\*\*|panic:|Error:|terraform:.*failed/i.test(body) && 
                                     !applyComplete && !planComplete;
            const isSuccess = (isApply && applyComplete) || (isPlan && !hasExplicitError) || (!hasExplicitError && (applyComplete || planComplete));

            // Extract plan summary
            const summaryMatch = body.match(/Plan: (\d+) to (add|import), (\d+) to change, (\d+) to destroy/);
            const planSummary = summaryMatch ? summaryMatch[0] : '';

            // Find output section
            const lines = body.split('\n');
            const diffStartIdx = lines.findIndex(l => l.includes('<details><summary>Show Output</summary>'));
            const diffEndIdx = lines.findIndex((l, i) => i > diffStartIdx && l.includes('</details>'));

            if (diffStartIdx === -1) {
              console.log('Cannot find output section, skipping format');
              return;
            }

            // Extract raw output content (without the details wrapper)
            const outputContent = lines.slice(diffStartIdx + 1, diffEndIdx).join('\n');

            // Build trigger reference
            const triggerRef = triggerComment
              ? `[@${triggerComment.user.login.replace('[bot]', '')}](${triggerComment.html_url})`
              : 'autoplan';

            // Build compact status header
            const statusIcon = isSuccess ? '‚úÖ' : '‚ùå';
            const statusText = isSuccess ? 'Succeeded' : 'Failed';

            // Build next step guidance - only show apply command if all plans succeed
            let nextStep;
            if (isPlan && isSuccess) {
              nextStep = `Run \`atlantis apply -p ${project}\``;
            } else if (isPlan && !isSuccess) {
              nextStep = 'Fix errors, then `atlantis plan`';
            } else if (isApply && isSuccess) {
              nextStep = '‚ú® Ready to merge';
            } else {
              nextStep = 'Fix errors, then `atlantis plan`';
            }

            // Compact format: Status | Project | Summary | Next step
            const formattedBody = [
              `## ${statusIcon} ${stage} ${statusText} | \`${project}\``,
              planSummary ? `**${planSummary}**` : '',
              `üìç \`${dir}\` | üéØ ${triggerRef} | üí° ${nextStep}`,
              '',
              '<details><summary>üìú Output</summary>',
              '',
              outputContent,
              '',
              '</details>'
            ].filter(Boolean).join('\n');

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: formattedBody
            });

            console.log('Comment formatted');
