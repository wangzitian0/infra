name: CI Pipeline

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      command:
        description: "Command (plan, apply, bootstrap, e2e)"
        required: true
        default: "plan"
      layers:
        description: "Layers (comma-separated or 'all')"
        required: false
        default: "all"
      action:
        description: "Action (for bootstrap: plan/apply)"
        required: false
        default: "plan"
      digger_apply:
        description: "Trigger Digger apply for L2/L3 (set to true by bootstrap-apply)"
        type: boolean
        required: false
        default: false
      run_e2e:
        description: "Run E2E tests after Digger apply"
        type: boolean
        required: false
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
  actions: write
  statuses: write

env:
  PYTHON_VERSION: "3.11"
  TERRAGRUNT_VERSION: "0.68.4"

jobs:
  # =============================================================
  # Parse: Determine execution mode
  # =============================================================
  parse:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.parse.outputs.mode }}
      command: ${{ steps.parse.outputs.command }}
      layers: ${{ steps.parse.outputs.layers }}
      pr_number: ${{ steps.parse.outputs.pr_number }}
      should_run: ${{ steps.parse.outputs.should_run }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Parse Event
        id: parse
        env:
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci parse

      - name: Acknowledge (PR comment)
        if: github.event_name == 'issue_comment' && steps.parse.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'eyes'
              });
            } catch (e) {}

      - name: Init Dashboard
        if: steps.parse.outputs.pr_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci init --pr ${{ steps.parse.outputs.pr_number }}

  # =============================================================
  # Digger: Standard Plan/Apply (L2/L3)
  # =============================================================
  digger:
    needs: parse
    if: needs.parse.outputs.mode == 'digger' && needs.parse.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: digger-${{ needs.parse.outputs.pr_number || github.run_id }}
      cancel-in-progress: ${{ needs.parse.outputs.command != 'apply' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}
          
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Digger
        uses: diggerhq/digger@v0.6.80
        with:
          setup-terragrunt: true
          terragrunt-version: ${{ env.TERRAGRUNT_VERSION }}
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          DIGGER_TOKEN: ${{ secrets.DIGGER_BEARER_TOKEN }}
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}

  # =============================================================
  # PyCI: Unified Python Runner (Bootstrap, Verify, Custom)
  # =============================================================
  pyci:
    needs: parse
    if: needs.parse.outputs.mode == 'python' && needs.parse.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: pyci-${{ needs.parse.outputs.pr_number || github.run_id }}
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'issue_comment' && format('refs/pull/{0}/head', needs.parse.outputs.pr_number) || github.ref }}
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        # Always run setup as bootstrap/verify need it. Cheap for others.
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}
          # Bootstrap needs tf_state_key override? 
          # bootstrap.py handles its own init backend config usually? 
          # Actually bootstrap.py calls terraform init.
          # The terraform-setup action mainly writes credentials.
          
      - name: Run CI
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          PYTHONPATH: ${{ github.workspace }}/tools
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
          # Pass specific inputs for manual dispatch
          INPUT_ACTION: ${{ inputs.action }} 
        run: python -m ci run

  # =============================================================
  # Post-Merge: Bootstrap Apply (L1)
  # =============================================================
  bootstrap-apply:
    needs: parse
    if: needs.parse.outputs.mode == 'post-merge'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Bootstrap Apply
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci bootstrap apply

      - name: Trigger Digger Apply (L2/L3)
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -e
          echo "Triggering Digger apply for L2/L3 layers..."
          
          # Trigger workflow
          gh workflow run ci.yml -f digger_apply=true -f run_e2e=true
          
          echo "Workflow triggered. Waiting for it to start..."
          sleep 10
          
          # Get the latest workflow run ID for this workflow
          run_id=$(gh run list --workflow=ci.yml --limit 1 --json databaseId --jq '.[0].databaseId')
          
          if [ -z "$run_id" ]; then
            echo "::error::Failed to get triggered workflow run ID"
            exit 1
          fi
          
          echo "Watching workflow run: $run_id"
          
          # Wait for Digger apply to complete
          gh run watch $run_id --exit-status --interval 30 || {
            echo "::error::Digger apply failed or timed out"
            exit 1
          }
          
          echo "âœ… Digger apply and E2E tests completed successfully"

  # =============================================================
  # Digger Apply (L2/L3) - triggered via workflow_dispatch
  # Note: Cannot run on push events (GitHub blocks recursive triggers)
  # =============================================================
  digger-apply:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && inputs.digger_apply == true
    steps:
      - uses: actions/checkout@v4
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}
          
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Digger Apply
        uses: diggerhq/digger@v0.6.80
        with:
          setup-terragrunt: true
          terragrunt-version: ${{ env.TERRAGRUNT_VERSION }}
          # Explicitly disable locks for apply if needed, or rely on Digger default
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          DIGGER_TOKEN: ${{ secrets.DIGGER_BEARER_TOKEN }}
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}

  # =============================================================
  # E2E: Post-Apply Verification (triggered after Digger apply)
  # =============================================================
  e2e-tests:
    needs: [digger-apply]
    if: github.event_name == 'workflow_dispatch' && inputs.run_e2e == true
    uses: ./.github/workflows/e2e-tests.yml
    with:
      test_scope: 'all'
      commit_sha: ${{ github.sha }}
    secrets: inherit
