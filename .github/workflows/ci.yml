name: CI Pipeline

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      command:
        description: "Command (plan, apply, bootstrap, e2e)"
        required: true
        default: "plan"
      layers:
        description: "Layers (comma-separated or 'all')"
        required: false
        default: "all"
      action:
        description: "Action (for bootstrap: plan/apply)"
        required: false
        default: "plan"

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
  actions: write
  statuses: write

env:
  PYTHON_VERSION: "3.11"
  TERRAGRUNT_VERSION: "0.68.4"

jobs:
  # =============================================================
  # Parse: Determine execution mode
  # =============================================================
  parse:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.parse.outputs.mode }}
      command: ${{ steps.parse.outputs.command }}
      layers: ${{ steps.parse.outputs.layers }}
      pr_number: ${{ steps.parse.outputs.pr_number }}
      should_run: ${{ steps.parse.outputs.should_run }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Parse Event
        id: parse
        env:
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci parse

      - name: Acknowledge (PR comment)
        if: github.event_name == 'issue_comment' && steps.parse.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'eyes'
              });
            } catch (e) {}

      - name: Init Dashboard
        if: steps.parse.outputs.pr_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci init --pr ${{ steps.parse.outputs.pr_number }}

  # =============================================================
  # Digger: Standard Plan/Apply (L2/L3)
  # =============================================================
  digger:
    needs: parse
    if: needs.parse.outputs.mode == 'digger' && needs.parse.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: digger-${{ needs.parse.outputs.pr_number || github.run_id }}
      cancel-in-progress: ${{ needs.parse.outputs.command != 'apply' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}
          
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Digger
        uses: diggerhq/digger@v0.6.80
        with:
          setup-terragrunt: true
          terragrunt-version: ${{ env.TERRAGRUNT_VERSION }}
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          DIGGER_TOKEN: ${{ secrets.DIGGER_BEARER_TOKEN }}
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}

  # =============================================================
  # PyCI: Unified Python Runner (Bootstrap, Verify, Custom)
  # =============================================================
  pyci:
    needs: parse
    if: needs.parse.outputs.mode == 'python' && needs.parse.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: pyci-${{ needs.parse.outputs.pr_number || github.run_id }}
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'issue_comment' && format('refs/pull/{0}/head', needs.parse.outputs.pr_number) || github.ref }}
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        # Always run setup as bootstrap/verify need it. Cheap for others.
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}
          # Bootstrap needs tf_state_key override? 
          # bootstrap.py handles its own init backend config usually? 
          # Actually bootstrap.py calls terraform init.
          # The terraform-setup action mainly writes credentials.
          
      - name: Run CI
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          PYTHONPATH: ${{ github.workspace }}/tools
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
          # Pass specific inputs for manual dispatch
          INPUT_ACTION: ${{ inputs.action }} 
        run: python -m ci run

  # =============================================================
  # Post-Merge: Bootstrap Apply (L1)
  # =============================================================
  bootstrap-apply:
    needs: parse
    if: needs.parse.outputs.mode == 'post-merge'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Bootstrap Apply
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci bootstrap apply

  # =============================================================
  # Post-Merge: Direct Terragrunt Apply (L2/L3)
  # Note: Digger orchestrator doesn't support push events, so we use direct terragrunt
  # =============================================================
  terragrunt-apply:
    needs: [parse, bootstrap-apply]
    if: needs.parse.outputs.mode == 'post-merge'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}
          
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Apply Platform Layer
        working-directory: platform
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          terragrunt init -reconfigure
          terragrunt apply -auto-approve -no-color

      - name: Apply Data Staging
        working-directory: envs/staging/data
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          terragrunt init -reconfigure
          terragrunt apply -auto-approve -no-color

      - name: Apply Data Prod
        working-directory: envs/prod/data
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          terragrunt init -reconfigure
          terragrunt apply -auto-approve -no-color

  # =============================================================
  # E2E: Post-Merge Verification (Chained)
  # =============================================================
  e2e-tests:
    needs: [parse, terragrunt-apply]
    if: needs.parse.outputs.mode == 'post-merge'
    uses: ./.github/workflows/e2e-tests.yml
    with:
      test_scope: 'all'
      commit_sha: ${{ github.sha }}
    secrets: inherit
