name: CI Pipeline

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      command:
        description: "Command (plan, apply, bootstrap, e2e)"
        required: true
        default: "plan"
      layers:
        description: "Layers (comma-separated or 'all')"
        required: false
        default: "all"
      action:
        description: "Action (for bootstrap: plan/apply)"
        required: false
        default: "plan"

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
  actions: write
  statuses: write

env:
  PYTHON_VERSION: "3.11"
  TERRAGRUNT_VERSION: "0.68.4"

jobs:
  # =============================================================
  # Parse: Determine execution mode
  # =============================================================
  parse:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.parse.outputs.mode }}
      command: ${{ steps.parse.outputs.command }}
      layers: ${{ steps.parse.outputs.layers }}
      pr_number: ${{ steps.parse.outputs.pr_number }}
      should_run: ${{ steps.parse.outputs.should_run }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Parse Event
        id: parse
        env:
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci parse

      - name: Acknowledge (PR comment)
        if: github.event_name == 'issue_comment' && steps.parse.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'eyes'
              });
            } catch (e) {}

      - name: Init Dashboard
        if: steps.parse.outputs.pr_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci init --pr ${{ steps.parse.outputs.pr_number }}

  # =============================================================
  # Digger: Standard Plan/Apply (L2/L3)
  # =============================================================
  digger:
    needs: parse
    if: needs.parse.outputs.mode == 'digger' && needs.parse.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: digger-${{ needs.parse.outputs.pr_number || github.run_id }}
      cancel-in-progress: ${{ needs.parse.outputs.command != 'apply' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}
          
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Digger
        id: digger
        uses: diggerhq/digger@v0.6.80
        with:
          setup-terragrunt: true
          terragrunt-version: ${{ env.TERRAGRUNT_VERSION }}
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          DIGGER_TOKEN: ${{ secrets.DIGGER_BEARER_TOKEN }}
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}

      - name: Update Dashboard
        if: always() && needs.parse.outputs.pr_number != ''
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          PYTHONPATH: ${{ github.workspace }}/tools
        run: |
          # Determine stage from command
          STAGE="plan-platform"
          COMMAND="${{ needs.parse.outputs.command }}"
          
          if [[ "$COMMAND" == "apply" ]]; then
            STAGE="apply"
          elif [[ "$COMMAND" == *"bootstrap"* ]]; then
            STAGE="plan-bootstrap"
          fi
          
          # Map job outcome to status
          OUTCOME="${{ steps.digger.outcome }}"
          STATUS="pending"
          case "$OUTCOME" in
            success) STATUS="success" ;;
            failure) STATUS="failure" ;;
            cancelled) STATUS="skipped" ;;
            *) STATUS="failure" ;;
          esac
          
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          python -m ci update \
            --pr ${{ needs.parse.outputs.pr_number }} \
            --stage "$STAGE" \
            --status "$STATUS" \
            --link "$RUN_URL"

  # =============================================================
  # PyCI: Unified Python Runner (Bootstrap, Verify, Custom)
  # =============================================================
  pyci:
    needs: parse
    if: needs.parse.outputs.mode == 'python' && needs.parse.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: pyci-${{ needs.parse.outputs.pr_number || github.run_id }}
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'issue_comment' && format('refs/pull/{0}/head', needs.parse.outputs.pr_number) || github.ref }}
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        # Always run setup as bootstrap/verify need it. Cheap for others.
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}
          # Bootstrap needs tf_state_key override? 
          # bootstrap.py handles its own init backend config usually? 
          # Actually bootstrap.py calls terraform init.
          # The terraform-setup action mainly writes credentials.
          
      - name: Run CI
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          PYTHONPATH: ${{ github.workspace }}/tools
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
          # Pass specific inputs for manual dispatch
          INPUT_ACTION: ${{ inputs.action }} 
        run: python -m ci run

  # =============================================================
  # Post-Merge: Bootstrap Apply (L1)
  # =============================================================
  bootstrap-apply:
    needs: parse
    if: needs.parse.outputs.mode == 'post-merge'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Bootstrap Apply
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          PYTHONPATH: ${{ github.workspace }}/tools
        run: python -m ci bootstrap apply

  # =============================================================
  # Post-Merge: Digger Apply (L2/L3)
  # =============================================================
  digger-apply:
    needs: [parse, bootstrap-apply]
    if: needs.parse.outputs.mode == 'post-merge'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Generate App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.INFRA_FLASH_APP_ID }}
          private-key: ${{ secrets.INFRA_FLASH_APP_KEY }}
          
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: ./.github/actions/terraform-setup
        with:
          secrets_json: ${{ toJSON(secrets) }}

      - name: Digger Apply
        uses: diggerhq/digger@v0.6.80
        with:
          setup-terragrunt: true
          terragrunt-version: ${{ env.TERRAGRUNT_VERSION }}
          # Explicitly disable locks for apply if needed, or rely on Digger default
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          DIGGER_TOKEN: ${{ secrets.DIGGER_BEARER_TOKEN }}
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}

  # =============================================================
  # E2E: Post-Merge Verification (Chained)
  # =============================================================
  e2e-tests:
    needs: [parse, digger-apply]
    if: needs.parse.outputs.mode == 'post-merge'
    uses: ./.github/workflows/e2e-tests.yml
    with:
      test_scope: 'all'
      commit_sha: ${{ github.sha }}
    secrets: inherit
